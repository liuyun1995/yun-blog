我们都知道物理网络媒介容易受到环境因素影响而产生波动，导致传输的数据受损或者丢失，如何在这种环境下确保接收方接收到的数据就是发送方所发送的数据，这一问题困扰了科学家很多年。一般来说目前主要有两种解决思路，对于数据受损问题我们可以采用差错校验码来检测和恢复，而对于数据丢失问题我们只能通过重传数据包来解决。TCP协议是一种可靠的数据传输协议，为了保证数据传输的正确性，TCP同时采用了差错校验码和重传机制。本篇我们重点关注TCP的重传机制，重传数据包是在检测出丢包的情况下进行触发的，TCP会根据接收端返回至发送端的一系列确认信息来判断是否出现丢包。根据判断丢包依据的不同，重传又分为超时重传、快速重传和选择重传，下面分别为大家进行介绍。

#### 1. 超时重传

发送方在发送每个报文段时会为该报文段设置一个计时器，若在指定时间内未收到接收方对该报文段的确认信息，则判断可能出现丢包，因此需要发送方进行重传。这里麻烦的一点是，我们应该设置超时时间为多少才合适？若超时时间设置的过短，则可能导致重复发送报文进而引起网络拥塞；若超时时间设置的过长，则可能导致网络变的空闲进而降低吞吐量。因此重传超时时间(Retransmission TimeOut，RTO)的设置是一门科学，我们需要用统计学的方法来对样本进行统计，从而估算出一个合理的超时时间。从发送数据报到接收到相应确认信息的时间间隔我们称之为往返时间(Round Trip Time，RTT)，那么我们是否可以将RTO设置为此前收集到的RTT的样本均值呢？

##### 1.1 常见的方案

1）根据RTT样本的平均值进行估计



2）根据RTT样本的加权平均值进行估计
$$
 SRTT\gets\alpha(SRTT)+(1-\alpha)RTT \tag{1.1}
$$

这里常量 $\alpha$ 是平滑因子

$$
 RTO = min(ubound，max(lbound，(SRTT)\beta)) \tag{1.2}
$$

3）根据RTT样本的加权平均值和偏差进行估计
$$
 srtt\gets(1-g)(srtt)+(g)M \tag{1.3}
$$
$$
 rttvar\gets(1-h)(rttvar)+(h)(\mid{M-srtt}\mid) \tag{1.4}
$$
$$
 RTO = srtt + 4(rttvar) \tag{1.5}
$$

##### 1.2 Linux采用的方案



#### 2. 快速重传



#### 3. 选择重传

#### 4. 可靠性问题

##### 4.1 伪重传

##### 4.2 包失序

##### 4.3 包重复

